/* SPDX-License-Identifier: GPL-2.0
 *
 * Copyright (c) 2020 Codefair Semiconductor Technology Co., Ltd.
 *		http://www.codefairsemi.com
 *
 */
#include <linux/types.h>
#include <linux/kernel.h>
#include <linux/clk.h>
#include <linux/device.h>
#include <linux/delay.h>
#include <linux/gpio/consumer.h>
#include <linux/i2c.h>
#include <linux/module.h>
#include <linux/pm_runtime.h>
#include <linux/regulator/consumer.h>
#include <linux/sysfs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/gpio.h>
#include <dt-bindings/gpio/gpio.h>
#include <linux/of.h>
#include <linux/of_device.h>
#include <linux/of_gpio.h>


/* 45Mhz * 4 Binning */
#define GC0308_PIXEL_RATE		(45 * 1000 * 1000 * 4)
#define GC0308_XVCLK_FREQ		24000000

#define CHIP_ID				0x9b
#define GC0308_CHIP_ID_H	(0x56)
#define GC0308_CHIP_ID_L	(0x48)

#define GC0308_REG_CHIP_ID		0x00

#define GC0308_REG_CTRL_MODE		0x0100
#define GC0308_MODE_SW_STANDBY		0x0
#define GC0308_MODE_STREAMING		BIT(0)

#define GC0308_REG_EXPOSURE		0x3500
#define	GC0308_EXPOSURE_MIN		4
#define	GC0308_EXPOSURE_STEP		1
#define GC0308_VTS_MAX			0x7fff

#define GC0308_REG_ANALOG_GAIN		0x3509
#define	ANALOG_GAIN_MIN			0x10
#define	ANALOG_GAIN_MAX			0xf8
#define	ANALOG_GAIN_STEP		1
#define	ANALOG_GAIN_DEFAULT		0xf8

#define GC0308_REG_DIGI_GAIN_H		0x350a
#define GC0308_REG_DIGI_GAIN_L		0x350b
#define GC0308_DIGI_GAIN_L_MASK		0x3f
#define GC0308_DIGI_GAIN_H_SHIFT	6
#define GC0308_DIGI_GAIN_MIN		0
#define GC0308_DIGI_GAIN_MAX		(0x4000 - 1)
#define GC0308_DIGI_GAIN_STEP		1
#define GC0308_DIGI_GAIN_DEFAULT	1024

#define GC0308_REG_TEST_PATTERN		0x4503
#define	GC0308_TEST_PATTERN_ENABLE	0x80
#define	GC0308_TEST_PATTERN_DISABLE	0x0

#define GC0308_REG_VTS			0x380e

#define REG_NULL			0xFF

#define GC0308_REG_VALUE_08BIT		1
#define GC0308_REG_VALUE_16BIT		2
#define GC0308_REG_VALUE_24BIT		3

#define GC0308_LANES			2
#define GC0308_BITS_PER_SAMPLE		10

#define GC0308_CNT   1
#define DEV_NAME	"GC0308"



#define SEN_MAGIC 'N'
#define IOCTL_SENINIT _IOW (SEN_MAGIC, 1, int)
#define IOCTL_SENREGW _IOW (SEN_MAGIC, 2, int)
#define IOCTL_SENREGR _IOW (SEN_MAGIC, 3, int)
#define IOCTL_SENREGWB _IOW (SEN_MAGIC, 4, int)

static const char * const GC0308_supply_names[] = {
	"avdd",		/* Analog power */
	"dovdd",	/* Digital I/O power */
	"dvdd",		/* Digital core power */
};

#define GC0308_NUM_SUPPLIES ARRAY_SIZE(GC0308_supply_names)

struct regval {
	u8 addr;
	u8 val;
};
struct ioctl_data {		
	unsigned int reg;
	unsigned char value;
	unsigned char bit;
};

struct GC0308_mode {
	u32 width;
	u32 height;
	u32 max_fps;
	u32 hts_def;
	u32 vts_def;
	u32 exp_def;
	const struct regval *reg_list;
};

struct GC0308 {
	dev_t devid;			/*  	 */
	struct cdev cdev;		/* cdev 	*/
	struct class *class;	/*  		*/
	struct device *device;	/* 	 */
	struct device_node	*nd; /*  */
	int major;			/*  */
	void *private_data;	/*  */
	int chipid, als, ps;		/*  */
	struct i2c_client *client;
    const char *type;
};
static struct GC0308 GC0308devd;

static const struct regval GC0308_global_regs[] = {
#if 1                                  //rgb565
		    {0xfe , 0x80},

			{0xfe , 0x00},   // set page0

			{0xd2 , 0x80},   // close AEC 80
			{0x22 , 0x55},   // close AWB 55

		//	{0x03 , 0x01},
		//	{0x04 , 0x2c},
			{0x5a , 0x56},
			{0x5b , 0x40},
			{0x5c , 0x4a},

			{0x22 , 0x57},   // Open AWB

			{0x01 , 0x65},//FA
			{0x02 , 0x12},
			{0x0f , 0x00},

#if 0
			{0x03 , 0x01},
			{0x04 , 0x2c},

			{0xe2 , 0x00},   //anti-flicker step [11:8]
			{0xe3 , 0x64},   //anti-flicker step [7:0]

			{0xe4 , 0x02},   //exp level 0  16.67fps
			{0xe5 , 0x58},
			{0xe6 , 0x03},   //exp level 1  12.5fps
			{0xe7 , 0x20},
			{0xe8 , 0x04},   //exp level 2  8.33fps
			{0xe9 , 0xb0},
			{0xea , 0x09},   //exp level 3  4.00fps
			{0xeb , 0xc4},
#endif
#if 1
            {0x03 , 0x00},//01
            {0x04 , 0xc8},//2c 96

            {0xe2 , 0x00},   //anti-flicker step [11:8]
            {0xe3 , 0x64},   //anti-flicker step [7:0]

            {0xe4 , 0x01},   //exp level 0  16.67fps
            {0xe5 , 0x2c},
            {0xe6 , 0x01},   //exp level 1  12.5fps
            {0xe7 , 0x90},
            {0xe8 , 0x02},   //exp level 2  8.33fps
            {0xe9 , 0x58},
            {0xea , 0x04},   //exp level 3  4.00fps
            {0xeb , 0xb0},
#endif

		//	{0xec , 0x00},

			{0x05 , 0x00},
			{0x06 , 0x00},
			{0x07 , 0x00},
			{0x08 , 0x00},
			{0x09 , 0x01},
			{0x0a , 0xe8},//e8
			{0x0b , 0x02},
			{0x0c , 0x88},
			{0x0d , 0x02},
			{0x0e , 0x02},
			{0x10 , 0x22},
			{0x11 , 0xfd},
			{0x12 , 0x2a},
			{0x13 , 0x00},
	//		{0x14 , 0x10},
			{0x15 , 0x0a},
			{0x16 , 0x05},
			{0x17 , 0x01},
			{0x18 , 0x44},
			{0x19 , 0x44},
			{0x1a , 0x1e},
			{0x1b , 0x00},
			{0x1c , 0xc1},
			{0x1d , 0x08},
			{0x1e , 0x60},
			{0x1f , 0x16},//16


			{0x20 , 0xcf},//ff
			{0x21 , 0xf0},
			{0x22 , 0x57},
			{0x24 , 0xa6},		///yuv--a2    rgb565 a6
		   // {0x24 , 0xb1},		///only y
			{0x25 , 0x0f},

			//output sync_mode
			{0x26 , 0x03},
			{0x2f , 0x01},
			{0x30 , 0xf7},
			{0x31 , 0x50},
			{0x32 , 0x00},
			{0x39 , 0x04},
			{0x3a , 0x18},
			{0x3b , 0x20},
			{0x3c , 0x00},
			{0x3d , 0x00},
			{0x3e , 0x00},
			{0x3f , 0x00},
			{0x50 , 0x10},
			{0x53 , 0x82},
			{0x54 , 0x80},
			{0x55 , 0x80},
			{0x56 , 0x82},
			{0x8b , 0x40},
			{0x8c , 0x40},
			{0x8d , 0x40},
			{0x8e , 0x2e},
			{0x8f , 0x2e},
			{0x90 , 0x2e},
			{0x91 , 0x3c},
			{0x92 , 0x50},
			{0x5d , 0x12},
			{0x5e , 0x1a},
			{0x5f , 0x24},
			{0x60 , 0x07},
			{0x61 , 0x15},
			{0x62 , 0x08},
			{0x64 , 0x03},
			{0x66 , 0xe8},
			{0x67 , 0x86},
			{0x68 , 0xa2},
			{0x69 , 0x18},
			{0x6a , 0x0f},
			{0x6b , 0x00},
			{0x6c , 0x5f},
			{0x6d , 0x8f},
			{0x6e , 0x55},
			{0x6f , 0x38},
			{0x70 , 0x15},
			{0x71 , 0x33},
			{0x72 , 0xdc},
			{0x73 , 0x80},
			{0x74 , 0x02},
			{0x75 , 0x3f},
			{0x76 , 0x02},
			{0x77 , 0x36},
			{0x78 , 0x88},
			{0x79 , 0x81},
			{0x7a , 0x81},
			{0x7b , 0x22},
			{0x7c , 0xff},
			{0x93 , 0x48},
			{0x94 , 0x00},
			{0x95 , 0x05},
			{0x96 , 0xe8},
			{0x97 , 0x40},
			{0x98 , 0xf0},
			{0xb1 , 0x38},
			{0xb2 , 0x38},
			{0xbd , 0x38},
			{0xbe , 0x36},
			{0xd0 , 0xc9},
			{0xd1 , 0x10},
			//{0xd2 , 0x90},
			{0xd3 , 0x80},
			{0xd5 , 0xf2},
			{0xd6 , 0x16},
			{0xdb , 0x92},
			{0xdc , 0xa5},
			{0xdf , 0x23},
			{0xd9 , 0x00},
			{0xda , 0x00},
			{0xe0 , 0x09},

			{0xed , 0x04},
			{0xee , 0xa0},
			{0xef , 0x40},
			{0x80 , 0x03},
			{0x80 , 0x03},
			{0x9F , 0x10},
			{0xA0 , 0x20},
			{0xA1 , 0x38},
			{0xA2 , 0x4E},
			{0xA3 , 0x63},
			{0xA4 , 0x76},
			{0xA5 , 0x87},
			{0xA6 , 0xA2},
			{0xA7 , 0xB8},
			{0xA8 , 0xCA},
			{0xA9 , 0xD8},
			{0xAA , 0xE3},
			{0xAB , 0xEB},
			{0xAC , 0xF0},
			{0xAD , 0xF8},
			{0xAE , 0xFD},
			{0xAF , 0xFF},
			{0xc0 , 0x00},
			{0xc1 , 0x10},
			{0xc2 , 0x1C},
			{0xc3 , 0x30},
			{0xc4 , 0x43},
			{0xc5 , 0x54},
			{0xc6 , 0x65},
			{0xc7 , 0x75},
			{0xc8 , 0x93},
			{0xc9 , 0xB0},
			{0xca , 0xCB},
			{0xcb , 0xE6},
			{0xcc , 0xFF},
			{0xf0 , 0x02},
			{0xf1 , 0x01},
			{0xf2 , 0x01},
			{0xf3 , 0x30},
			{0xf9 , 0x9f},
			{0xfa , 0x78},

			//---------------------------------------------------------------
			{0xfe , 0x01},// set page1

			{0x00 , 0xf5},
			{0x02 , 0x1a},
			{0x0a , 0xa0},
			{0x0b , 0x60},
			{0x0c , 0x08},
			{0x0e , 0x4c},
			{0x0f , 0x39},
			{0x11 , 0x3f},
			{0x12 , 0x72},
			{0x13 , 0x13},
			{0x14 , 0x42},
			{0x15 , 0x43},
			{0x16 , 0xc2},
			{0x17 , 0xa8},
			{0x18 , 0x18},
			{0x19 , 0x40},
			{0x1a , 0xd0},
			{0x1b , 0xf5},
			{0x70 , 0x40},
			{0x71 , 0x58},
			{0x72 , 0x30},
			{0x73 , 0x48},
			{0x74 , 0x20},
			{0x75 , 0x60},
			{0x77 , 0x20},
			{0x78 , 0x32},
			{0x30 , 0x03},
			{0x31 , 0x40},
			{0x32 , 0xe0},
			{0x33 , 0xe0},
			{0x34 , 0xe0},
			{0x35 , 0xb0},
			{0x36 , 0xc0},
			{0x37 , 0xc0},
			{0x38 , 0x04},
			{0x39 , 0x09},
			{0x3a , 0x12},
			{0x3b , 0x1C},
			{0x3c , 0x28},
			{0x3d , 0x31},
			{0x3e , 0x44},
			{0x3f , 0x57},
			{0x40 , 0x6C},
			{0x41 , 0x81},
			{0x42 , 0x94},
			{0x43 , 0xA7},
			{0x44 , 0xB8},
			{0x45 , 0xD6},
			{0x46 , 0xEE},
			{0x47 , 0x0d},

			{0xfe , 0x00}, // set page0
			{0xd2 , 0x90},


			//-----------Update the registers 2010/07/06-------------//
			//Registers of Page0
			{0xfe , 0x00}, // set page0
			{0x10 , 0x26},
			{0x11 , 0x0d},  // fd,modified by mormo 2010/07/06
			{0x1a , 0x2a},  // 1e,modified by mormo 2010/07/06

			{0x1c , 0x49}, // c1,modified by mormo 2010/07/06
			{0x1d , 0x9a}, // 08,modified by mormo 2010/07/06
			{0x1e , 0x61}, // 60,modified by mormo 2010/07/06

			{0x3a , 0x20},

			{0x50 , 0x14},  // 10,modified by mormo 2010/07/06
			{0x53 , 0x80},
			{0x56 , 0x80},

			{0x8b , 0x20}, //LSC
			{0x8c , 0x20},
			{0x8d , 0x20},
			{0x8e , 0x14},
			{0x8f , 0x10},
			{0x90 , 0x14},

			{0x94 , 0x02},
			{0x95 , 0x07},
			{0x96 , 0xe0},

			{0xb1 , 0x40}, // YCPT
			{0xb2 , 0x40},
			{0xb3 , 0x40},
			{0xb6 , 0xe0},

			{0xd0 , 0xcb}, // AECT  c9,modifed by mormo 2010/07/06
			{0xd3 , 0x48}, // 80,modified by mormor 2010/07/06

			{0xf2 , 0x02},
			{0xf7 , 0x12},
			{0xf8 , 0x0a},

			//Registers of Page1
			{0xfe , 0x01},// set page1
			{0x02 , 0x20},
			{0x04 , 0x10},
			{0x05 , 0x08},
			{0x06 , 0x20},
			{0x08 , 0x0a},

			{0x0e , 0x44},
			{0x0f , 0x32},
			{0x10 , 0x41},
			{0x11 , 0x37},
			{0x12 , 0x22},
			{0x13 , 0x19},
			{0x14 , 0x44},
			{0x15 , 0x44},

			{0x19 , 0x50},
			{0x1a , 0xd8},

			{0x32 , 0x10},

			{0x35 , 0x00},
			{0x36 , 0x80},
			{0x37 , 0x00},
			//-----------Update the registers end---------//
			{0xfe , 0x00},// set page0

	//-----------GAMMA Select(2)---------------//
			{0x9F , 0x0E},
			{0xA0 , 0x1C},
			{0xA1 , 0x34},
			{0xA2 , 0x48},
			{0xA3 , 0x5A},
			{0xA4 , 0x6B},
			{0xA5 , 0x7B},
			{0xA6 , 0x95},
			{0xA7 , 0xAB},
			{0xA8 , 0xBF},
			{0xA9 , 0xCE},
			{0xAA , 0xD9},
			{0xAB , 0xE4},
			{0xAC , 0xEC},
			{0xAD , 0xF7},
			{0xAE , 0xFD},
			{0xAF , 0xFF},

	 /*GC0308_GAMMA_Select,
		1:                                             //smallest gamma curve
			{0x9F , 0x0B},
			{0xA0 , 0x16},
			{0xA1 , 0x29},
			{0xA2 , 0x3C},
			{0xA3 , 0x4F},
			{0xA4 , 0x5F},
			{0xA5 , 0x6F},
			{0xA6 , 0x8A},
			{0xA7 , 0x9F},
			{0xA8 , 0xB4},
			{0xA9 , 0xC6},
			{0xAA , 0xD3},
			{0xAB , 0xDD},
			{0xAC , 0xE5},
			{0xAD , 0xF1},
			{0xAE , 0xFA},
			{0xAF , 0xFF},

		2:
			{0x9F , 0x0E},
			{0xA0 , 0x1C},
			{0xA1 , 0x34},
			{0xA2 , 0x48},
			{0xA3 , 0x5A},
			{0xA4 , 0x6B},
			{0xA5 , 0x7B},
			{0xA6 , 0x95},
			{0xA7 , 0xAB},
			{0xA8 , 0xBF},
			{0xA9 , 0xCE},
			{0xAA , 0xD9},
			{0xAB , 0xE4},
			{0xAC , 0xEC},
			{0xAD , 0xF7},
			{0xAE , 0xFD},
			{0xAF , 0xFF},

		3:
			{0x9F , 0x10},
			{0xA0 , 0x20},
			{0xA1 , 0x38},
			{0xA2 , 0x4E},
			{0xA3 , 0x63},
			{0xA4 , 0x76},
			{0xA5 , 0x87},
			{0xA6 , 0xA2},
			{0xA7 , 0xB8},
			{0xA8 , 0xCA},
			{0xA9 , 0xD8},
			{0xAA , 0xE3},
			{0xAB , 0xEB},
			{0xAC , 0xF0},
			{0xAD , 0xF8},
			{0xAE , 0xFD},
			{0xAF , 0xFF},

		4:
			{0x9F , 0x14},
			{0xA0 , 0x28},
			{0xA1 , 0x44},
			{0xA2 , 0x5D},
			{0xA3 , 0x72},
			{0xA4 , 0x86},
			{0xA5 , 0x95},
			{0xA6 , 0xB1},
			{0xA7 , 0xC6},
			{0xA8 , 0xD5},
			{0xA9 , 0xE1},
			{0xAA , 0xEA},
			{0xAB , 0xF1},
			{0xAC , 0xF5},
			{0xAD , 0xFB},
			{0xAE , 0xFE},
			{0xAF , 0xFF},

		5:								//largest gamma curve
			{0x9F , 0x15},
			{0xA0 , 0x2A},
			{0xA1 , 0x4A},
			{0xA2 , 0x67},
			{0xA3 , 0x79},
			{0xA4 , 0x8C},
			{0xA5 , 0x9A},
			{0xA6 , 0xB3},
			{0xA7 , 0xC5},
			{0xA8 , 0xD5},
			{0xA9 , 0xDF},
			{0xAA , 0xE8},
			{0xAB , 0xEE},
			{0xAC , 0xF3},
			{0xAD , 0xFA},
			{0xAE , 0xFD},
			{0xAF , 0xFF}, */
			{0x14 , 0x10},

#endif
    {REG_NULL, 0x00},
};
static const struct regval GC0308_global_regs_black[] = {
#if 0
	{0xfe,0x00},
	{0xec,0x20},
	{0x05,0x00},
	{0x06,0x00},
	{0x07,0x00},
	{0x08,0x00},
	{0x09,0x01},
	{0x0a,0xe8},
	{0x0b,0x02},
	{0x0c,0x88},
	{0x0d,0x02},
	{0x0e,0x02},
	{0x10,0x26},
	{0x11,0x0d},
	{0x12,0x2a},
	{0x13,0x00},

	{0x15,0x0a},
	{0x16,0x05},
	{0x17,0x01},
	{0x18,0x44},
	{0x19,0x44},
	{0x1a,0x2a},
	{0x1b,0x00},
	{0x1c,0x49},
	{0x1d,0x9a},
	{0x1e,0x61},
	{0x1f,0x3f},  //pad drv <=24MHz, use 0x00 is ok   00

	{0x20,0x48},   //sharpnow (ISP only gamma and intp)
	{0x21,0xfa},
	{0x22,0x17},

    {0x24,0xb1},   //sharpnow formart Y only
	//{0x24,0xb7},   //b7=RGBx555  //sharpnow formart Y only
	//{0x24,0xb8},   //

	{0x25,0x0f},
	{0x26,0x03}, // 0x03 used in v133,0x3a used in 1903

	{0x28,0x00},  // no div clk
	{0x2d,0x0a},
	{0x2f,0x01},
	{0x30,0xf7},
	{0x31,0x50},
	{0x32,0x00},
	{0x33,0x28},
	{0x34,0x2a},
	{0x35,0x28},
	{0x39,0x04},
	{0x3a,0x20},
	{0x3b,0x20},
	{0x3c,0x00},
	{0x3d,0x00},
	{0x3e,0x00},
	{0x3f,0x00},
	{0x50,0x14}, // 0x14
	{0x52,0x41},
	{0x53,0x80},
	{0x54,0x80},
	{0x55,0x80},
	{0x56,0x80},
	{0x8b,0x20},
	{0x8c,0x20},
	{0x8d,0x20},
	{0x8e,0x14},
	{0x8f,0x10},
	{0x90,0x14},
	{0x91,0x3c},
	{0x92,0x50},
	{0x5d,0x12},
	{0x5e,0x1a},
	{0x5f,0x24},
	{0x60,0x07},
	{0x61,0x15},
	{0x62,0x08}, // 0x08
	{0x64,0x03},  // 0x03
	{0x66,0xe8},
	{0x67,0x86},
	{0x68,0x82},
	{0x69,0x18},
	{0x6a,0x0f},
	{0x6b,0x00},
	{0x6c,0x5f},
	{0x6d,0x8f},
	{0x6e,0x55},
	{0x6f,0x38},
	{0x70,0x15},
	{0x71,0x33},
	{0x72,0x00}, // sharpnow no edge enhancement
	{0x73,0x00},
	{0x74,0x02},
	{0x75,0x3f},
	{0x76,0x02},
	{0x77,0x38}, // 0x47
	{0x78,0x88},
	{0x79,0x81},
	{0x7a,0x81},
	{0x7b,0x22},
	{0x7c,0xff},
	{0x93,0x48},  //color matrix default
	{0x94,0x02},
	{0x95,0x07},
	{0x96,0xe0},
	{0x97,0x40},
	{0x98,0xf0},
	{0xb1,0x40},
	{0xb2,0x40},
	{0xb3,0x40}, //0x40
	{0xb6,0xe0},
	{0xbd,0x38},
	{0xbe,0x36},
	{0xd0,0xCB},
	{0xd1,0x10},
	{0xd2,0x10},  // sharpnow turn off AE
	{0xd3,0x48},
	{0xd5,0xF2},
	{0xd6,0x16},
	{0xdb,0x97}, // fatest
	{0xdc,0xA7}, // fatest
	{0xdf,0x23},
	{0xd9,0x00},
	{0xda,0x00},
	{0xe0,0x09},
	{0xed,0x04},
	{0xee,0xa0},
	{0xef,0x40},
	{0x80,0x03},

	{0x9F,0x10},
	{0xA0,0x20},
	{0xA1,0x38},
	{0xA2,0x4e},
	{0xA3,0x63},
	{0xA4,0x76},
	{0xA5,0x87},
	{0xA6,0xa2},
	{0xA7,0xb8},
	{0xA8,0xca},
	{0xA9,0xd8},
	{0xAA,0xe3},
	{0xAB,0xeb},
	{0xAC,0xf0},
	{0xAD,0xF8},
	{0xAE,0xFd},
	{0xAF,0xFF},

	{0xc0,0x00},
	{0xc1,0x10},
	{0xc2,0x1c},
	{0xc3,0x30},
	{0xc4,0x43},
	{0xc5,0x54},
	{0xc6,0x65},
	{0xc7,0x75},
	{0xc8,0x93},
	{0xc9,0xB0},
	{0xca,0xCB},
	{0xcb,0xE6},
	{0xcc,0xFF},
	{0xf0,0x02},
	{0xf1,0x01},
	{0xf2,0x02},
	{0xf3,0x30},

	{0xfe,0x01},
	{0x00,0xf5},
	{0x02,0x20},
	{0x04,0x10},
	{0x05,0x08},
	{0x06,0x20},
	{0x08,0x0a},
	{0x0a,0xa0},
	{0x0b,0x60},
	{0x0c,0x08},
	{0x0e,0x44},
	{0x0f,0x32},
	{0x10,0x41},
	{0x11,0x37},
	{0x12,0x22},
	{0x13,0x19},
	{0x14,0x44},
	{0x15,0x44},
	{0x16,0xc2},
	{0x17,0xA8},
	{0x18,0x18},
	{0x19,0x50},
	{0x1a,0xd8},
	{0x1b,0xf5},
	{0x70,0x40},
	{0x71,0x58},
	{0x72,0x30},
	{0x73,0x48},
	{0x74,0x20},
	{0x75,0x60},
	{0x77,0x20},
	{0x78,0x32},
	{0x30,0x03},
	{0x31,0x40},
	{0x32,0x10},
	{0x33,0xe0},
	{0x34,0xe0},
	{0x35,0x00},
	{0x36,0x80},
	{0x37,0x00},
	{0x38,0x04},
	{0x39,0x09},
	{0x3a,0x12},
	{0x3b,0x1C},
	{0x3c,0x28},
	{0x3d,0x31},
	{0x3e,0x44},
	{0x3f,0x57},
	{0x40,0x6C},
	{0x41,0x81},
	{0x42,0x94},
	{0x43,0xA7},
	{0x44,0xB8},
	{0x45,0xD6},
	{0x46,0xEE},
	{0x47,0x0d},
	{0x53, 0x83},
	{0x62,0xf7},
	{0x63,0x68},
	{0x64,0xd3},
	{0x65,0xd3},
	{0x66,0x60},

	{0xfe,0x00},
	{0x03, 0x00},
	{0x04, 0x20},
	{0x05, 0x00},
	{0x06, 0x00},
	{0x07, 0x00},
	{0x08, 0x00},
	//{0x14, 0x13}, /** 0x14[1:0] 正常图像00  镜像翻转01 垂直翻转10 镜像垂直翻转11**/
	{0x14, 0x10}, /** 0x14[1:0] 正常图像00  镜像翻转01 垂直翻转10 镜像垂直翻转11**/

	{0x15, 0x0a},
	{0x16, 0x05},
	{0x17, 0x01},
	{0x20, 0xcf},
	{0x6f, 0x00},
	{0xb3, 0x40},
	{0xb4, 0x40},
	{0xb5, 0x00},
	{0xc0, 0x00},
	{0xc1, 0x10},
	{0xc2, 0x19},
	{0xc3, 0x2d},
	{0xc4, 0x3c},
	{0xc5, 0x50},
	{0xc6, 0x5a},
	{0xc7, 0x64},
	{0xc8, 0x78},
	{0xc9, 0x96},
	{0xca, 0xb4},
	{0xcb, 0xe1},
	{0xcc, 0xff},

	{0xd2, 0x90},
	{0xd1, 0x01},

	{0xeb, 0xc4},
	{0xed, 0x01},
	{0xee, 0x80},
	{0xef, 0x40},
	{0xf7, 0x27},
	{0xf8, 0x1e},
	{0xf9, 0xa0},  //
	{0xfa, 0x78},

	{0xfe,0x00},
	{0x0f,0x00},   //0x00
	{0x01,0xe0},   //0x6a
	{0x02,0x0c},   //0x70   25fps anti-flicker
	{0xe2,0x00},
	{0xe3,0x78},
	{0xe4,0x00},
	{0xe5,0xf0},
	{0xe6,0x00},
	{0xe7,0xf0},
	{0xe8,0x00},
	{0xe9,0xf0},
	{0xea,0x00},
	{0xeb,0xf0},
	{0xd1,0x10},// fastest AE Speed
	{0x6e,0xa5},
	{0x6f,0xa8},
	{0xd3,0x20},
#endif
	#if 1

	{0xfe,0x00},
	{0xec,0x20},
	{0x05,0x00},
	{0x06,0x00},
	{0x07,0x00},
	{0x08,0x00},
	{0x09,0x01},
	{0x0a,0xe8},
	{0x0b,0x02},
	{0x0c,0x88},
	{0x0d,0x02},
	{0x0e,0x02},
	{0x10,0x26},
	{0x11,0x0d},
	{0x12,0x2a},
	{0x13,0x00},

	{0x15,0x0a},
	{0x16,0x05},
	{0x17,0x01},
	{0x18,0x44},
	{0x19,0x44},
	{0x1a,0x2a},
	{0x1b,0x00},
	{0x1c,0x40},//49
	{0x1d,0xb9},//9a
	{0x1e,0x61},
	{0x1f,0x15},  //pad drv <=24MHz, use 0x00 is ok   00 3f

	{0x20,0x48},   //sharpnow (ISP only gamma and intp) 48
	{0x21,0xFa},//fa
	{0x22,0x17},//17 57

	{0x24,0xb1},   //Y only 0xb1
	//{0x24,0xb7},   //b7 output bayer pattern
	//{0x24,0xb8},   //

	{0x25,0x0f},
	{0x26,0x03}, // 0x03 used in v133,0x3a used in 1903

	{0x28,0x00},  // no div clk
	{0x2d,0x0a},
	{0x2f,0x01},
	{0x30,0xf7},
	{0x31,0x50},
	{0x32,0x00},//00
	{0x33,0x28},
	{0x34,0x2a},
	{0x35,0x28},
	{0x39,0x04},
	{0x3a,0x20},
	{0x3b,0x20},
	{0x3c,0x00},
	{0x3d,0x00},
	{0x3e,0x00},
	{0x3f,0x00},
	{0x50,0x14}, // 0x14
	{0x52,0x41},
	{0x53,0x80},
	{0x54,0x80},
	{0x55,0x80},
	{0x56,0x80},
	{0x8b,0x20},
	{0x8c,0x20},
	{0x8d,0x20},
	{0x8e,0x14},
	{0x8f,0x10},
	{0x90,0x14},
	{0x91,0x3c},
	{0x92,0x50},
	{0x5d,0x12},
	{0x5e,0x1a},
	{0x5f,0x24},
	{0x60,0x07},
	{0x61,0x15},
	{0x62,0x08}, // 0x08
	{0x64,0x03},  // 0x03
	{0x66,0xe8},
	{0x67,0x86},
	{0x68,0x82},
	{0x69,0x18},
	{0x6a,0x0f},
	{0x6b,0x00},
	{0x6c,0x5f},
	{0x6d,0x8f},
	{0x6e,0x55},
	{0x6f,0x38},
	{0x70,0x15},
	{0x71,0x33},
	{0x72,0x00}, // sharpnow no edge enhancement
	{0x73,0x00},
	{0x74,0x02},
	{0x75,0x3f},
	{0x76,0x02},
	{0x77,0x38}, // 0x47
	{0x78,0x88},
	{0x79,0x81},
	{0x7a,0x81},
	{0x7b,0x22},
	{0x7c,0xff},
	{0x93,0x48},  //color matrix default
	{0x94,0x02},
	{0x95,0x07},
	{0x96,0xe0},
	{0x97,0x40},
	{0x98,0xf0},
	{0xb1,0x40},
	{0xb2,0x40},
	{0xb3,0x40}, //0x40
	{0xb6,0xe0},
	{0xbd,0x38},
	{0xbe,0x36},
	{0xd0,0xCB},
	{0xd1,0x10},
	{0xd2,0x10},  // sharpnow turn off AE
	{0xd3,0x48},
	{0xd5,0xF2},
	{0xd6,0x16},
	{0xdb,0x97}, // fatest
	{0xdc,0xA7}, // fatest
	{0xdf,0x23},
	{0xd9,0x00},
	{0xda,0x00},
	{0xe0,0x09},
	{0xed,0x04},
	{0xee,0xa0},
	{0xef,0x40},
	{0x80,0x03},

	{0x9F,0x10},
	{0xA0,0x20},
	{0xA1,0x38},
	{0xA2,0x4e},
	{0xA3,0x63},
	{0xA4,0x76},
	{0xA5,0x87},
	{0xA6,0xa2},
	{0xA7,0xb8},
	{0xA8,0xca},
	{0xA9,0xd8},
	{0xAA,0xe3},
	{0xAB,0xeb},
	{0xAC,0xf0},
	{0xAD,0xF8},
	{0xAE,0xFd},
	{0xAF,0xFF},

	{0xc0,0x00},
	{0xc1,0x10},
	{0xc2,0x1c},
	{0xc3,0x30},
	{0xc4,0x43},
	{0xc5,0x54},
	{0xc6,0x65},
	{0xc7,0x75},
	{0xc8,0x93},
	{0xc9,0xB0},
	{0xca,0xCB},
	{0xcb,0xE6},
	{0xcc,0xFF},
	{0xf0,0x02},
	{0xf1,0x01},
	{0xf2,0x02},
	{0xf3,0x30},

	{0xfe,0x01},
	{0x00,0xf5},
	{0x02,0x20},
	{0x04,0x10},
	{0x05,0x08},
	{0x06,0x20},
	{0x08,0x0a},
	{0x0a,0xa0},
	{0x0b,0x60},
	{0x0c,0x08},
	{0x0e,0x44},
	{0x0f,0x32},
	{0x10,0x41},
	{0x11,0x37},
	{0x12,0x22},
	{0x13,0x19},
	{0x14,0x44},
	{0x15,0x44},
	{0x16,0xc2},
	{0x17,0xA8},
	{0x18,0x18},
	{0x19,0x50},
	{0x1a,0xd8},
	{0x1b,0xf5},
	{0x70,0x40},
	{0x71,0x58},
	{0x72,0x30},
	{0x73,0x48},
	{0x74,0x20},
	{0x75,0x60},
	{0x77,0x20},
	{0x78,0x32},
	{0x30,0x03},
	{0x31,0x40},
	{0x32,0x40},//0x10
	{0x33,0xe0},
	{0x34,0xe0},
	{0x35,0x00},
	{0x36,0x80},
	{0x37,0x00},
	{0x38,0x04},
	{0x39,0x09},
	{0x3a,0x12},
	{0x3b,0x1C},
	{0x3c,0x28},
	{0x3d,0x31},
	{0x3e,0x44},
	{0x3f,0x57},
	{0x40,0x6C},
	{0x41,0x81},
	{0x42,0x94},
	{0x43,0xA7},
	{0x44,0xB8},
	{0x45,0xD6},
	{0x46,0xEE},
	{0x47,0x0d},
	{0x53, 0x83},
	{0x62,0xf7},
	{0x63,0x68},
	{0x64,0xd3},
	{0x65,0xd3},
	{0x66,0x60},

	{0xfe,0x00},
	{0x03, 0x00},
	{0x04, 0x96},//0x20
	{0x05, 0x00},
	{0x06, 0x00},
	{0x07, 0x00},
	{0x08, 0x00},
	//{0x14, 0x13}, /** 0x14[1:0] 正常图像00  镜像翻转01 垂直翻转10 镜像垂直翻转11**/
	{0x14, 0x10}, /** 0x14[1:0] 正常图像00  镜像翻转01 垂直翻转10 镜像垂直翻转11**/

	{0x15, 0x0a},
	{0x16, 0x05},
	{0x17, 0x01},
	{0x20, 0xcf},
	{0x6f, 0x00},
	{0xb3, 0x40},
	{0xb4, 0x40},
	{0xb5, 0x00},
	{0xc0, 0x00},
	{0xc1, 0x10},
	{0xc2, 0x19},
	{0xc3, 0x2d},
	{0xc4, 0x3c},
	{0xc5, 0x50},
	{0xc6, 0x5a},
	{0xc7, 0x64},
	{0xc8, 0x78},
	{0xc9, 0x96},
	{0xca, 0xb4},
	{0xcb, 0xe1},
	{0xcc, 0xff},

	{0xd2, 0x90},
	{0xd1, 0x01},

//	{0xeb, 0xc4},
	{0xed, 0x01},
	{0xee, 0x80},
	{0xef, 0x40},
	{0xf7, 0x27},
	{0xf8, 0x1e},
	{0xf9, 0xa0},  //
	{0xfa, 0x78},

	{0xfe,0x00},
	{0x0f,0x02},   //0x00
	{0x01,0x6a},   //0x6a  e0
	{0x02,0x12},   //0x70   25fps anti-flicker 0c
#if 0 //huanghe_moren
    {0x03,0x00},
    {0x04,0x64},//0x20 0x96
	{0xe2,0x00},
	{0xe3,0x78},
	{0xe4,0x00},
	{0xe5,0xf0},
	{0xe6,0x00},
	{0xe7,0xf0},
	{0xe8,0x00},
	{0xe9,0xf0},
	{0xea,0x00},
	{0xeb,0xf0},
#endif
#if 1 //20fps
	{0x03 , 0x01},
	{0x04 , 0x2c},

	{0xe2 , 0x00},   //anti-flicker step [11:8]
	{0xe3 , 0x96},   //anti-flicker step [7:0]//64

	{0xe4 , 0x00},   //exp level 0  16.67fps
	{0xe5 , 0x96},
	{0xe6 , 0x02},   //exp level 1  12.5fps
	{0xe7 , 0x58},
	{0xe8 , 0x03},   //exp level 2  8.33fps
	{0xe9 , 0x84},
	{0xea , 0x04},   //exp level 3  4.00fps
	{0xeb , 0xb0},

#endif
#if 0 //30 fs
	{0x03 , 0x01},//01
	{0x04 , 0x2c},//2c 96

	{0xe2 , 0x00},   //anti-flicker step [11:8]
	{0xe3 , 0x64},   //anti-flicker step [7:0]

	{0xe4 , 0x00},   //exp level 0  16.67fps
	{0xe5 , 0x96},
	{0xe6 , 0x00},   //exp level 1  12.5fps
	{0xe7 , 0xfa},
	{0xe8 , 0x01},   //exp level 2  8.33fps
	{0xe9 , 0x5e},
	{0xea , 0x02},   //exp level 3  4.00fps
	{0xeb , 0x26},
#endif
	{0xd1,0x10},// fastest AE Speed
	{0x6e,0xa5},
	{0x6f,0xa8},
	{0xd3,0x40},//0x20
#endif
    {REG_NULL, 0x00},
};

#define GC0308_LINK_FREQ_420MHZ		420000000
static const s64 link_freq_menu_items[] = {
	GC0308_LINK_FREQ_420MHZ
};

static const char * const GC0308_test_pattern_menu[] = {
	"Disabled",
	"Vertical Color Bar Type 1",
	"Vertical Color Bar Type 2",
	"Vertical Color Bar Type 3",
	"Vertical Color Bar Type 4"
};
static void __GC0308_power_off(struct i2c_client *client)
{
	int pwdnnum = 0;
	enum of_gpio_flags  flags;
	int ret;
	// struct i2c_client *client = to_i2c_client(dev);
	pwdnnum= of_get_named_gpio_flags(client->dev.of_node, "pwdn-d041", 0, &flags);
	if (gpio_is_valid(pwdnnum)) {
		printk("pmoff-gpio = %d\n", pwdnnum);
		ret = gpio_request(pwdnnum, "pwdn-d031");
		// printk("pwdn-gpio request = %d\n", ret);
		gpio_direction_output(pwdnnum, 1);
		gpio_set_value(pwdnnum, 0);
		mdelay(20);
		gpio_set_value(pwdnnum, 1);
		gpio_free(pwdnnum);
	} 
	else{
    printk("gpio PWDN fail\n");
	}
	return ;
}

static int __GC0308_power_on(struct i2c_client *client)
{   
    int pwdnnum = 0;
    int ret;
    enum of_gpio_flags  flags;
    // struct i2c_client *client = to_i2c_client(dev);
	pwdnnum= of_get_named_gpio_flags(client->dev.of_node, "pwdn-d041", 0, &flags);
	if (gpio_is_valid(pwdnnum)) {
		printk("pmon pwdn-gpio = %d\n", pwdnnum);
		ret = gpio_request(pwdnnum, "pwdn-d041");
		// printk("pwdn-gpio request = %d\n", ret);
		gpio_direction_output(pwdnnum, 1);
		gpio_set_value(pwdnnum, 0);
		mdelay(20);
		// gpio_set_value(pwdnnum, 0);
		gpio_free(pwdnnum);
	} 
	else{
    printk("gpio PWDN fail\n");
	}
	return 0;
}
static int GC0308_read_reg(struct GC0308 *dev,  unsigned char reg,
		void *val)
{
	// struct i2c_client *client = v4l2_get_subdevdata(sd);
	// struct i2c_client *client = (struct i2c_client *)GC0308devdd->private_data;
	struct i2c_client *client = (struct i2c_client *)dev->private_data;
	unsigned char buf= reg;
	// struct i2c_msg msg[2];
	struct i2c_msg msg[2] = {
		[0] = {
			.addr	= client->addr,
			.flags	= 0,
			.len	= 1,
			.buf	= &buf,
		},
		[1] = {
			.addr	= client->addr,
			.flags	= I2C_M_RD,
			.len	= 1,
			.buf	= val,
		}
	};
	int ret;
	 // printk("read\n");
	ret = i2c_transfer(client->adapter, msg, 2);
	if (ret > 0)
		ret = 0;

	return ret;
}
static int GC0308_read_array(struct GC0308 *dev,const struct regval *regs)
{
	u32 i;
	int ret = 0;
	// unsigned char buf[200]={0};
	u8 data = 0;
	// unsigned char *value;
     // struct i2c_client *client = (struct i2c_client *)dev->private_data;
	for (i = 0; ret == 0 && regs[i].addr != REG_NULL; i++)
	{
		// printk("i2c read\n");
        ret = GC0308_read_reg(dev, regs[i].addr, &data);
        printk("GC0308 : %x = %x\n",regs[i].addr,data);

	}
	return ret;
}

static int GC0308_write_reg(struct GC0308 *dev, unsigned char reg,unsigned char value)
{
	struct i2c_client *client = (struct i2c_client *)dev->private_data;
	// unsigned char buf[3] = {reg >> 8, reg & 0xff, value};
	unsigned char buf[2] = {reg & 0xff, value};
	struct i2c_msg msg = {
		.addr	= client->addr,
		.flags	= 0,
		.len	= 2,
		.buf	= buf,
	};
	int ret;

	ret = i2c_transfer(client->adapter, &msg, 1);
	// if (ret > 0)
	// 	ret = 0;
	if(ret == 1) {
	ret = 0;
	} else {
	printk("i2c rd failed=%d reg=0x%06x value=%d\n",ret, reg, value);
	ret = -EREMOTEIO;
	}
	return ret;
}

static int GC0308_write_array(struct GC0308 *dev,const struct regval *regs)
{
	u32 i;
	int ret = 0;
	u8 data = 0;
     // struct i2c_client *client = (struct i2c_client *)dev->private_data;
	for (i = 0; ret == 0 && regs[i].addr != REG_NULL; i++)
	{
        ret = GC0308_write_reg(dev, regs[i].addr, regs[i].val);
        printk("GC0308 : %x = %x\n",regs[i].addr,regs[i].val );
        ret = GC0308_read_reg(dev, regs[i].addr, &data);
        printk("GC0308 : %x = %x\n",regs[i].addr,data);
        if(data==regs[i].val)
        {
         printk("i2c rwreg ok\n");
        }
	}
	return ret;
}

static int get_ofdata_str_type(struct GC0308 senser)
{
	// const char *type=csi->nd->name;
	 const char *type;
	// const char *name;
	struct device *dev = senser.device;
	struct device_node *node = dev->of_node;
	int ret;
    printk("senser type\n");
	ret = of_property_read_string(node, "function", &type);
	if (ret) {
		dev_warn(dev, "No csi  selected, using 5648\n");
		// csi->type = 5648;
	}
	 if (!strcmp(type, "black")) {
	 	printk("function=black\n");
	 }
	 else if (!strcmp(type, "color")) {
         printk("function=color\n");	
	 }
	 else{
	 	return -EINVAL;
	 }
    // senser.type=type;
    GC0308devd.type=type;
	return 0;
}
#if 0
static int ap3216c_read_regs(struct ap3216c_dev *dev, u8 reg, void *val, int len)
{
	int ret;
	struct i2c_msg msg[2];
	struct i2c_client *client = (struct i2c_client *)dev->private_data;

	/* msg[0]为发送要读取的首地址 */
	msg[0].addr = client->addr;			/* ap3216c地址 */
	msg[0].flags = 0;					/* 标记为发送数据 */
	msg[0].buf = &reg;					/* 读取的首地址 */
	msg[0].len = 1;						/* reg长度*/

	/* msg[1]读取数据 */
	msg[1].addr = client->addr;			/* ap3216c地址 */
	msg[1].flags = I2C_M_RD;			/* 标记为读取数据*/
	msg[1].buf = val;					/* 读取数据缓冲区 */
	msg[1].len = len;					/* 要读取的数据长度*/

	ret = i2c_transfer(client->adapter, msg, 2);
	if(ret == 2) {
		ret = 0;
	} else {
		printk("i2c rd failed=%d reg=%06x len=%d\n",ret, reg, len);
		ret = -EREMOTEIO;
	}
	return ret;
}
#endif



static int __GC0308_start_stream(struct GC0308 *dev)
{
	int ret=0;
	const char *stype;
	stype=GC0308devd.type;
	if (!strcmp(stype, "black")) {
	  printk("GC0308RAW\n");
	  ret = GC0308_write_array(dev,GC0308_global_regs_black);
	}
	else if (!strcmp(stype, "color")){
	  printk("GC0308RGB\n");
	 ret = GC0308_write_array(dev,GC0308_global_regs);
	}
	printk("GC0308 init dvp \n");
	return ret;
}

static int __GC0308_stop_stream(struct GC0308 *dev)
{
	int ret=0;
	struct i2c_client *client = (struct i2c_client *)dev->private_data;
	__GC0308_power_off(client);
	// ret = GC0308_write_reg(dev, GC0308_REG_CTRL_MODE,GC0308_MODE_SW_STANDBY);
	// if(ret)
	// printk("GC0308 stop error\n");	

	return ret;
}


static inline u32 GC0308_cal_delay(u32 cycles)
{
	return DIV_ROUND_UP(cycles, GC0308_XVCLK_FREQ / 1000 / 1000);
}


static int GC0308_detect(struct GC0308 *dev)
{
	unsigned char v;
	int ret;
	int id=0;

	ret = GC0308_read_reg(dev, 0x00, &v);
	if (ret < 0)
		return ret;
	id|=v;
	if (v != CHIP_ID)
		return -ENODEV;
	dev->chipid=id;
	printk("discover 0X%x\n", id);
	return 0;
}

/*
 * @description		: 
 * @param - inode 	: 
 * @param - filp 	: 
 * 					  
 * @return 			:
 */
static int GC0308_open(struct inode *inode, struct file *filp)
{
	// filp->private_data = &GC0308devd;
	struct i2c_client *client = (struct i2c_client *)GC0308devd.private_data;
	filp->private_data = &GC0308devd;
	__GC0308_power_on(client);
	__GC0308_start_stream(&GC0308devd);
	return 0;
}

/*
 * @description		: 
 * @param - filp 	: 
 * @param - buf 	: 
 * @param - cnt 	: 
 * @param - offt 	: 
 * @return 			: 
 */
static ssize_t GC0308_read(struct file *filp, char __user *buf, size_t cnt, loff_t *off)
{
	int data[1]={0};
	long err = 0;
	// int chipidnum;

	struct GC0308 *dev = (struct GC0308 *)filp->private_data;
	
	// GC0308_readdata(dev);
	// GC0308_detect(dev);

	data[0] = dev->chipid;
	// data[1] = dev->als;
	// data[2] = dev->ps;
	err = copy_to_user(buf, data, sizeof(data[1]));
	printk("Readid OV%x sensor\n", data[0]);
	return 0;
}
// ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
static ssize_t GC0308_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *off)
{
	// struct regval data[]={0};
	struct regval *data=NULL;
	long err = 0;
	int ret;
    struct regval *GC0308_data_regs=NULL;
	struct GC0308 *dev = (struct GC0308 *)filp->private_data;
	

	err = copy_from_user(data, buf, sizeof(buf));
	if(err < 0) {
	printk("kernel write failed!\r\n");
	return -EFAULT;
    }
    // memcpy(&GC0308_data_regs,(struct regval *)data,sizeof(data));
    memcpy(GC0308_data_regs,data,sizeof(buf));
    ret = GC0308_write_array(dev,GC0308_data_regs);
	if(ret)
		printk("GC0308 write error\n");	
	return 0;
}

/*
 * @description		: 
 * @param - filp 	: 
 * @return 			: 
 */
static int GC0308_release(struct inode *inode, struct file *filp)
{
	__GC0308_stop_stream(&GC0308devd);
	return 0;
}


static long senioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
	int ret,err;
	struct ioctl_data sendata;
	unsigned char kvalue=0;
    struct GC0308 *dev = (struct GC0308 *)filp->private_data;
    
    switch(cmd) {
		case IOCTL_SENINIT:
           break;
			
        case IOCTL_SENREGW:
            err = copy_from_user(&sendata, (struct ioctl_data *)arg, sizeof(struct ioctl_data));
            	if(err < 0) {
	        printk("senser write failed!\r\n");
	        return -EFAULT;
            }
            GC0308_write_reg(dev, sendata.reg, sendata.value);
           	printk("sen write reg %x=%x\n",sendata.reg,sendata.value);
		 // printk("REGW AFTER %x=%x\n", 0xa0180000+sendata.reg,readl(global_csi->regs + sendata.reg) );
			break;

        case IOCTL_SENREGWB:
			// if(sendata.value == 1)
			// {
			// 	set_bit_w(sendata.bit,sendata.reg);
			// 	printk("sen write reg bit %x=bit%x\n",sendata.reg,sendata.value);
			// }
			// else
			// {
			// 	clear_bit_w(sendata.bit,sendata.reg);
			// 	printk("sen write reg bit %x=bit%x\n",sendata.reg,sendata.value);
			// }
           	break;
            
        case IOCTL_SENREGR:			 
			// sendata.value = readl(sendata.reg)
            // unsigned char kvalue=0;
			err = copy_from_user(&sendata, (struct ioctl_data *)arg, sizeof(struct ioctl_data));
            	if(err < 0) {
	        printk("senser read reg failed!\r\n");
	        return -EFAULT;
            }
            ret = GC0308_read_reg(dev, sendata.reg, &kvalue);
            if (ret < 0)
            {
            	return ret;
            }
		    sendata.value=kvalue;
			if(copy_to_user( (struct ioctl_data *)arg, &sendata, sizeof(struct ioctl_data))){
				ret = -1;
			 	printk("sendata to user error\n");
			}
			// ret = GC0308_read_reg(dev, sendata.reg, sendata.value);	
			printk("sen read out reg  %x=%x\n",sendata.reg,sendata.value);
			break;
        default:
            printk("SENSER in the default\n");
            return -EINVAL;
    }
    return 0;
}


static int __maybe_unused GC0308_runtime_resume(struct device *dev)
{  
	
	struct i2c_client *client = to_i2c_client(dev);
	printk("pmon-gpio\n");
	__GC0308_power_on(client);
	return 0;
}

static int __maybe_unused GC0308_runtime_suspend(struct device *dev)
{
   
   struct i2c_client *client = to_i2c_client(dev);
   printk("pmoff-gpio\n");
	__GC0308_power_off(client);

	return 0;
}
static const struct dev_pm_ops GC0308_pm_ops = {
	SET_SYSTEM_SLEEP_PM_OPS(GC0308_runtime_suspend,GC0308_runtime_resume)
	SET_RUNTIME_PM_OPS(GC0308_runtime_suspend,GC0308_runtime_resume, NULL)
};

/* GC0308 */
static const struct file_operations GC0308_ops = {
	.owner = THIS_MODULE,
	.open = GC0308_open,
	.read = GC0308_read,
	.write = GC0308_write,
	.unlocked_ioctl  = senioctl,
	.release = GC0308_release,
};

 /*
  * @description     : 
  *                    
  * @param - client  : 
  * @param - id      : 
  * @return          : 
  */
static int GC0308_probe(struct i2c_client *client, const struct i2c_device_id *id)
{
	enum of_gpio_flags  flags;
	int pwdnnum = 0;
	int ret=0;
	
	/* major */
	if (GC0308devd.major) {
		GC0308devd.devid = MKDEV(GC0308devd.major, 0);
		register_chrdev_region(GC0308devd.devid, GC0308_CNT, DEV_NAME);
	} else {
		alloc_chrdev_region(&GC0308devd.devid, 0, GC0308_CNT, DEV_NAME);
		GC0308devd.major = MAJOR(GC0308devd.devid);
	}

	/* cdev */
	cdev_init(&GC0308devd.cdev, &GC0308_ops);
	cdev_add(&GC0308devd.cdev, GC0308devd.devid, GC0308_CNT);

	/* class */
	GC0308devd.class = class_create(THIS_MODULE, DEV_NAME);
	if (IS_ERR(GC0308devd.class)) {
		return PTR_ERR(GC0308devd.class);
	}

	/* device */
	GC0308devd.device = device_create(GC0308devd.class, NULL, GC0308devd.devid, NULL, DEV_NAME);
	if (IS_ERR(GC0308devd.device)) {
		return PTR_ERR(GC0308devd.device);
	}
 
	GC0308devd.private_data = client;
    pwdnnum= of_get_named_gpio_flags(client->dev.of_node, "sen-d034", 0, &flags);
	if (gpio_is_valid(pwdnnum)) {
		ret = gpio_request(pwdnnum, "sen-d031");
		gpio_direction_output(pwdnnum, 1);
		gpio_set_value(pwdnnum, 0);
		mdelay(20);
		// msleep(5);
		gpio_set_value(pwdnnum, 1);
		gpio_free(pwdnnum);
	}
	pwdnnum= of_get_named_gpio_flags(client->dev.of_node, "pwdn-d041", 0, &flags);
	if (gpio_is_valid(pwdnnum)) {
		ret = gpio_request(pwdnnum, "pwdn-d031");
		gpio_direction_output(pwdnnum, 1);
		gpio_set_value(pwdnnum, 1);
		mdelay(20);
		// msleep(5);
		gpio_set_value(pwdnnum, 0);
		gpio_free(pwdnnum);
	} 
	GC0308devd.device = &client->dev;
	get_ofdata_str_type(GC0308devd);
	 return 0;
}

/*
 * @description     : 
 * @param - client 	: 
 * @return          : 
 */
static int GC0308_remove(struct i2c_client *client)
{
	/*  */
	cdev_del(&GC0308devd.cdev);
	unregister_chrdev_region(GC0308devd.devid, GC0308_CNT);

	/* device class */
	device_destroy(GC0308devd.class, GC0308devd.devid);
	class_destroy(GC0308devd.class);
	pm_runtime_disable(&client->dev);
	if (!pm_runtime_status_suspended(&client->dev)){
		__GC0308_power_off(client);
	}
	
	pm_runtime_set_suspended(&client->dev);
	return 0;
}

/* i2c_device_id */
static const struct i2c_device_id GC0308_id[] = {
	{"ov,GC0308", 0},  
	{}
};

/* device_id */
static const struct of_device_id GC0308_of_match[] = {
	{ .compatible = "sm,gc0308dvp" },
	{ /* Sentinel */ }
};

/* i2c_driver */	
static struct i2c_driver GC0308_driver = {
	.probe = GC0308_probe,
	.remove = GC0308_remove,
	.driver = {
			.owner = THIS_MODULE,
		   	.name = "GC0308",
		   	.pm = &GC0308_pm_ops,
		   	.of_match_table = GC0308_of_match, 
		   },
	.id_table = GC0308_id,
};
module_i2c_driver(GC0308_driver);		   
MODULE_DESCRIPTION("OmniVision GC0308 sensor driver");
MODULE_LICENSE("GPL");
MODULE_AUTHOR("linronghua,Codefair");


